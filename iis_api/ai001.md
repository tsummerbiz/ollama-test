シニアソリューションアーキテクトとして、エンタープライズ環境での運用に耐えうる堅牢な実装プランを提示します。

Windows Server上のIISで動作させる場合、**アプリケーションプール（AppPool）の実行ユーザーが、指定されたディレクトリ（D:\www\apps...）に対して適切な読み書き権限を持っていること**が極めて重要です。

---

### 1. プロジェクト構成と NuGet パッケージ (`.csproj`)

以下のパッケージを追加してください。ロギングにはデファクトスタンダードである **Serilog** を使用し、日次ローテーションを実現します。

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.Authentication.Negotiate" Version="8.0.0" />
    <PackageReference Include="System.IdentityModel.Tokens.Jwt" Version="7.3.1" />
    <PackageReference Include="Serilog.AspNetCore" Version="8.0.0" />
    <PackageReference Include="Serilog.Sinks.File" Version="5.0.0" />
  </ItemGroup>
</Project>

```

---

### 2. RSA 鍵管理サービス (`RsaKeyService.cs`)

鍵の生成、保存、読み込み、および JWKS 形式への変換を担当します。

```csharp
using System.Security.Cryptography;
using Microsoft.IdentityModel.Tokens;

public class RsaKeyService
{
    private readonly string _keyPath;
    private readonly RSA _rsa;
    public RsaSecurityKey SigningKey { get; }
    public string KeyId { get; } = Guid.NewGuid().ToString();

    public RsaKeyService(IConfiguration config)
    {
        _keyPath = @"D:\www\apps\jwtauthapi\AppKeys\jwt_sig_key.pem";
        var directory = Path.GetDirectoryName(_keyPath)!;

        if (!Directory.Exists(directory)) Directory.CreateDirectory(directory);

        _rsa = RSA.Create(2048);

        if (File.Exists(_keyPath))
        {
            var pem = File.ReadAllText(_keyPath);
            _rsa.ImportFromPem(pem);
        }
        else
        {
            var pem = _rsa.ExportPkcs8PrivateKeyPem();
            File.WriteAllText(_keyPath, pem);
        }

        SigningKey = new RsaSecurityKey(_rsa) { KeyId = this.KeyId };
    }

    public object GetPublicJwks()
    {
        var parameters = _rsa.ExportParameters(false);
        return new
        {
            keys = new[]
            {
                new {
                    kty = "RSA",
                    use = "sig",
                    alg = "RS256",
                    kid = KeyId,
                    n = Base64UrlEncoder.Encode(parameters.Modulus),
                    e = Base64UrlEncoder.Encode(parameters.Exponent)
                }
            }
        };
    }
}

```

---

### 3. ユーザーデータソース (`UserDataSource.cs`)

`FileSystemWatcher` を使用して XML を監視し、スレッドセーフにキャッシュを更新します。

```csharp
using System.Xml.Linq;
using System.Collections.Concurrent;

public class UserDataSource : IDisposable
{
    private readonly string _xmlPath = @"D:\www\apps\jwtauthapi\auth_data.xml";
    private readonly FileSystemWatcher _watcher;
    private ConcurrentDictionary<string, UserConfig> _cache = new();
    private readonly ILogger<UserDataSource> _logger;

    public record UserConfig(string WindowsId, string Name, string Role, string AppCode);

    public UserDataSource(ILogger<UserDataSource> logger)
    {
        _logger = logger;
        LoadCache();

        _watcher = new FileSystemWatcher(Path.GetDirectoryName(_xmlPath)!, Path.GetFileName(_xmlPath));
        _watcher.NotifyFilter = NotifyFilters.LastWrite | NotifyFilters.FileName;
        _watcher.Changed += (s, e) => LoadCache();
        _watcher.EnableRaisingEvents = true;
    }

    private void LoadCache()
    {
        try
        {
            // ファイル書き込み中のロック競合を避けるためのリトライ処理
            Thread.Sleep(500); 
            var doc = XDocument.Load(_xmlPath);
            var users = doc.Descendants("User").Select(x => new UserConfig(
                x.Element("WindowsID")?.Value ?? "",
                x.Element("Name")?.Value ?? "",
                x.Element("Role")?.Value ?? "",
                x.Element("AppCode")?.Value ?? ""
            ));

            _cache = new ConcurrentDictionary<string, UserConfig>(
                users.ToDictionary(u => $"{u.WindowsId}_{u.AppCode}", u => u, StringComparer.OrdinalIgnoreCase)
            );
            _logger.LogInformation("Auth data XML reloaded successfully.");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to load auth_data.xml");
        }
    }

    public UserConfig? GetUser(string windowsId, string appCode) 
        => _cache.TryGetValue($"{windowsId}_{appCode}", out var user) ? user : null;

    public void Dispose() => _watcher.Dispose();
}

```

---

### 4. メインロジック (`Program.cs`)

Minimal API を構成し、認証・トークン発行エンドポイントを定義します。

```csharp
using System.Security.Claims;
using System.IdentityModel.Tokens.Jwt;
using Microsoft.AspNetCore.Authentication.Negotiate;
using Microsoft.IdentityModel.Tokens;
using Serilog;

var builder = WebApplication.CreateBuilder(args);

// Serilog 設定 (日次ローテーション)
Log.Logger = new LoggerConfiguration()
    .WriteTo.File(@"D:\www\apps\jwtauthapi\logs\log-.txt", rollingInterval: RollingInterval.Day)
    .CreateLogger();

builder.Host.UseSerilog();

// Services
builder.Services.AddSingleton<RsaKeyService>();
builder.Services.AddSingleton<UserDataSource>();
builder.Services.AddAuthentication(NegotiateDefaults.AuthenticationScheme).AddNegotiate();
builder.Services.AddAuthorization();

var app = builder.Build();

// JWKS Endpoint
app.MapGet("api/auth/jwks", (RsaKeyService rsa) => Results.Ok(rsa.GetPublicJwks()));

// Token Issuance Endpoint
app.MapGet("api/auth/token", async (HttpContext context, string appCode, UserDataSource dataSource, RsaKeyService rsa) =>
{
    var user = context.User;
    var windowsId = user.Identity?.Name; // DOMAIN\Username

    if (string.IsNullOrEmpty(windowsId)) return Results.Unauthorized();

    var userData = dataSource.GetUser(windowsId, appCode);
    if (userData == null)
    {
        Log.Warning("Access denied for user: {WindowsId} with AppCode: {AppCode}", windowsId, appCode);
        return Results.Forbid();
    }

    // JWT 生成
    var claims = new[]
    {
        new Claim(JwtRegisteredClaimNames.Sub, windowsId),
        new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()),
        new Claim("name", userData.Name),
        new Claim("role", userData.Role),
        new Claim("app_code", appCode)
    };

    var token = new JwtSecurityToken(
        issuer: "JwtAuthApi",
        audience: "Any",
        claims: claims,
        expires: DateTime.UtcNow.AddHours(8),
        signingCredentials: new SigningCredentials(rsa.SigningKey, SecurityAlgorithms.RsaSha256)
    );

    var jwt = new JwtSecurityTokenHandler().WriteToken(token);
    Log.Information("Token issued for: {WindowsId}", windowsId);
    
    return Results.Ok(new { access_token = jwt, token_type = "Bearer" });
}).RequireAuthorization();

app.Run();

```

---

### 5. IIS および フォルダ権限の設定

Windows Server上で正常に動作させるには、以下の権限設定が必須です。

#### 1. フォルダ権限の付与

IISのアプリケーションプール（例: `IIS AppPool\YourAppPoolName`）に対して、以下の権限を与えてください。

| パス | 必要な権限 | 理由 |
| --- | --- | --- |
| `D:\www\apps\jwtauthapi\AppKeys` | **変更 (Modify)** | RSA鍵ファイルの生成と読み込み |
| `D:\www\apps\jwtauthapi\logs` | **変更 (Modify)** | ログファイルの作成と書き込み |
| `D:\www\apps\jwtauthapi\auth_data.xml` | **読み取り (Read)** | ユーザー情報の取得 |

> **設定方法**: フォルダ右クリック > プロパティ > セキュリティ > 編集 > 追加 > 場所をローカルサーバーに変更 > `IIS AppPool\（アプリプール名）` を入力して追加。

#### 2. IIS の認証設定

1. IISマネージャーで当該サイトを選択。
2. **「認証」**を開く。
3. **「Windows 認証」** を **有効** にする。
4. **「匿名認証」** は、JWKSエンドポイントを外部公開したい場合は有効のままで構いませんが、`api/auth/token` にアクセスした際に Negotiate がトリガーされるよう、アプリケーション側で制御しています。

---

### 補足：XMLの構造例 (`auth_data.xml`)

```xml
<Users>
  <User>
    <WindowsID>DOMAIN\j.doe</WindowsID>
    <Name>John Doe</Name>
    <Role>Admin</Role>
    <AppCode>SALES_APP</AppCode>
  </User>
</Users>

```

**次に行うこと:** このコードをデプロイし、実際の `WindowsID` に合わせた XML を配置して動作確認を行ってください。必要であれば、XML の要素名や JWT の `issuer` などの微調整をお手伝いしましょうか？